# 1. Aggregator具体代码的优化
注⚠️：参考mysql中的group设计
## 优化前
```
// 将30s内相同的指标和标签聚合value  
func aggregator(targets []MonitorTarget, combinedTargets []MonitorTarget) []MonitorTarget {  
	// 按照metricName + tag分组  
	metricsMap := map[string][]MonitorTarget{}  
	for _, target := range targets {  
	//根据需要的规则将MetricModel放入对应的列表中  
	key := generateKeyFromMetric(target)  
	metricList, exists := metricsMap[key]  
	if !exists {  
		// 如果 key 不存在，创建一个空的 MetricModel 切片  
		metricList = []MonitorTarget{}
	}  
	metricList = append(metricList, target)  
	metricsMap[key] = metricList  
	}  
	logger.Infof("length of aggregator metricsMap:{}", len(metricsMap))  
	// 将每次收到的指标按照指标名称和tag聚合  
	for _, metrics := range metricsMap {  
	if len(metrics) == 0 {  
		continue  
	}  
	value := metrics[0].Value  
	for _, metric := range metrics[1:] {  
		value += metric.Value  
	}  
	combinedMetric := metrics[0]  
	combinedMetric.Value = value  
	combinedTargets = append(combinedTargets, combinedMetric)  
	}  
	return combinedTargets  
}
```
## 优化后
```
// 将30s内相同的指标和标签聚合value
func aggregator(targets []MonitorTarget, combinedTargets []MonitorTarget) []MonitorTarget {
    // 按照metricName + tag分组
    metricsMap := map[string]MonitorTarget{}
    for _, target := range targets {
        // 根据需要的规则将MetricModel放入对应的列表中
        key := generateKeyFromMetric(target)
        existingMetric, exists := metricsMap[key]
        if exists {
            // 如果存在相同的指标，则累加值
            existingMetric.Value += target.Value
            metricsMap[key] = existingMetric
        } else {
            // 如果不存在相同的指标，则将其添加到map中
            metricsMap[key] = target
        }
    }
    logger.Infof("length of aggregator metricsMap: %d", len(metricsMap))
    // 将map中的值存入结果列表中
    for _, combinedMetric := range metricsMap {
        combinedTargets = append(combinedTargets, combinedMetric)
    }
    return combinedTargets
}

```